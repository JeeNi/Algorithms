### 문제 1.
#### 문제 내용
문자열을 원소로 하는 두 개의 배열(배열1, 배열2)이 있다. 어떤 원소가 배열 1에 포함되나 배열2에 포함되지 않고, 이런 원소가 1개 존재한다고 할 때, 해당 원소를 출력하여라. (단, 배열1,2 에는 중복된 원소가 포함될 수 있으며, 중복원소의 갯수가 배열1에서 보다 배열2에서 더 적을때, 포함되지 않는 것으로 한다.)

#### 문제 분석
구하는 것 :  어떤 원소의 출력

자료 : 배열1, 배열2

조건: 
1. 어떤 원소는 배열1에는 포함되지만 배열2에는 포함되지 않는다.
2. 어떤 원소가 중복되어 포함되는 경우 배열1에 포함된 갯수가 배열2에 포함된 갯수보다 1개 많다

#### 풀이 계획
#### 계획1.
- 배열2의 원소에 대한 반복문을 작성한다. 
- 배열1에서 반복문의 변수가 원소로 존재하는 경우 해당 원소를 삭제한다.
- 마지막 남은 한개를 출력한다.
#####  실행.

	for element in arr2 :
		arr1.remove(element)
	print(arr1[0])

#####  실패.
- 배열의 크기가 큰 경우, 알고리즘을 수행하는 시간이 기준치 보다 오래 걸렸다.   
##### 문제점.
- 배열 2의 원소갯수를 n 이라고 하고,  string 비교를 기본 연산으로 삼은 경우,  시간 복잡도가 n^2으로 나타난다. 
	
#### 계획 2.
- 배열1과 배열2를 오름차순으로 정렬한다.
- 배열1과 배열2의 원소를 index에 따라 순차적으로 비교한다. 
- 동일한 index에서 두 배열의 원소가 같지 않다면 이때, 결과를 출력한다. 

##### 실행.

	answer = ''
	arr1.sort()
	arr2.sort()
	for i in range(len(arr1)) :
		if i == len(arr1) - 1 or arr1[i] != arr2[i] :
			answer = arr[i]
			break
	print(arr[i])

##### 성공.
- 배열의 크기가 큰 경우에도 기준치 이내의 수행시간으로 통과하였다.
##### 원인분석.
- 정렬의 경우 알고리즘에 따라 시간복잡도가 n^2 보다 작아지는 것들이 있다. 
- 정렬의 연산 횟수를 n * logn 이라고 할때, 최악의 경우 총 연산 횟수는 2 n * log n  + n 이 된다. 
