### 문제 1.
#### 문제 내용
문자열을 원소로 하는 두 개의 배열(배열1, 배열2)이 있다. 어떤 원소가 배열 1에 포함되나 배열2에 포함되지 않고, 이런 원소가 1개 존재한다고 할 때, 해당 원소를 출력하여라. (단, 배열1,2 에는 중복된 원소가 포함될 수 있으며, 중복원소의 갯수가 배열1에서 보다 배열2에서 더 적을때, 포함되지 않는 것으로 한다.)

#### 문제 분석
구하는 것 :  어떤 원소의 출력

자료 : 배열1, 배열2

조건: 
1. 어떤 원소는 배열1에는 포함되지만 배열2에는 포함되지 않는다.
2. 어떤 원소가 중복되어 포함되는 경우 배열1에 포함된 갯수가 배열2에 포함된 갯수보다 1개 많다

#### 풀이 계획
#### 계획1.
- 배열2의 원소에 대한 반복문을 작성한다. 
- 배열1에서 반복문의 변수가 원소로 존재하는 경우 해당 원소를 삭제한다.
- 마지막 남은 한개를 출력한다.

#####  실행.

	for element in arr2 :
		arr1.remove(element)
	print(arr1[0])


#####  실패.
- 배열의 크기가 큰 경우, 알고리즘을 수행하는 시간이 기준치 보다 오래 걸렸다.   

##### 문제점.
- 배열에서 하나의 원소를 삭제할 때 기본 연산의 횟수는 배열의 원소갯수에 비례한다.
- 배열2의 원소 갯수를 n 개라 하면 총 기본 연산의 횟수는 n^2이 된다. (삭제를 n 번 수행)
- 데이터 갯수의 제곱에 비례하여 연산 시간이 증가 하게 된다.
- python list 연산들의 시간복잡도

![image](./listComplexity.png)
	
#### 계획 2.
- 배열1과 배열2를 오름차순으로 정렬한다.
- 배열1과 배열2의 원소를 index에 따라 순차적으로 비교한다. 
- 동일한 index에서 두 배열의 원소가 같지 않다면 이때, 결과를 출력한다. 

##### 실행.

	answer = ''
	arr1.sort()
	arr2.sort()
	for i in range(len(arr1)) :
		if i == len(arr1) - 1 or arr1[i] != arr2[i] :
			answer = arr[i]
			break
	print(answer)

##### 성공.
- 배열의 크기가 큰 경우에도 기준치 이내의 수행시간으로 통과하였다.

##### 원인분석.
- 정렬의 경우 알고리즘에 따라 시간복잡도가 n^2 보다 작아지는 것들이 있다. 
- 정렬의 연산 횟수를 n * logn 이라고 할때, 최악의 경우 총 연산 횟수는 2 n * log n  + n 이 된다. 

### 문제2. 프로그래머스 체육복
##### 풀이 문제점 1. 
	
	for number in lost :
		if exist(reserve, number) :
			lost.remove(number)

위와 같은 코드에서 number를 lost에서 지우고 다음 순서로 이동할 경우 하나가 누락되는 문제가 생김.

##### 풀이 문제점 2.
파이썬 예약어 in 의 적절한 활용. list 에서 특정 원소의 존재 여부에 따라 True, False를 반환한다. 

	testArray = [1, 2, 3, 4, 5]
	existence = 2 in testArray
	
	
	
